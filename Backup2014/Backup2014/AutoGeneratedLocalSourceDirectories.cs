/*
Programming by Fred Keultjes

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

*/
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Threading.Tasks;

namespace Backup2014
{
    public class AutoGeneratedLocalSourceDirectories
    {
        internal class FolderTempNodeInfo
        {
            internal string FolderPath;
            internal bool Included = false;
            internal bool IncludedByExclude = false;
            internal bool Excluded = false;
            internal FolderTempNodeInfo ParentNode = null;
            internal List<FolderTempNodeInfo> SubFolders = new List<FolderTempNodeInfo>();

            internal FolderTempNodeInfo(string folderPath)
            {
                this.FolderPath = folderPath;
            }
            internal FolderTempNodeInfo FindSubFolder(string folderPath)
            {
                foreach( FolderTempNodeInfo node in SubFolders )
                {
                    if (string.Compare(node.FolderPath, folderPath, true) == 0)
                        return node;
                }
                return null;
            }

            internal bool IsExcludedByParent
            {
                get
                {
                    FolderTempNodeInfo cur = this;
                    while( cur.ParentNode != null )
                    {
                        cur = cur.ParentNode;
                        if( cur.Included)
                            return false;
                        if( cur.Excluded)
                            return true;
                    };
                    return false;
                }
            }
        }

        private FolderTempNodeInfo root;
        private Dictionary<string, FolderTempNodeInfo> mapPathToNode = new Dictionary<string, FolderTempNodeInfo>();

        public AutoGeneratedLocalSourceDirectories()
        {
            root = new FolderTempNodeInfo(string.Empty);

            DriveInfo[] drives = DriveInfo.GetDrives();
            foreach( DriveInfo drive in drives )
            {
                if( drive.DriveType == DriveType.Fixed )
                {
                    Include(drive.RootDirectory.FullName);
                }
            }

            // first determine windows directories, not to back up

            // include 
            Include(Environment.SpecialFolder.Desktop);
            Include(Environment.SpecialFolder.Programs);
            Include(Environment.SpecialFolder.Personal);
            Include(Environment.SpecialFolder.MyDocuments);
            Include(Environment.SpecialFolder.Favorites);
            Include(Environment.SpecialFolder.Startup);
            Include(Environment.SpecialFolder.SendTo);
            Include(Environment.SpecialFolder.StartMenu);
            Include(Environment.SpecialFolder.MyMusic);
            Include(Environment.SpecialFolder.MyVideos);
            Include(Environment.SpecialFolder.DesktopDirectory);
            Include(Environment.SpecialFolder.CommonStartMenu);
            Include(Environment.SpecialFolder.CommonStartup);
            Include(Environment.SpecialFolder.CommonAdminTools);
            Include(Environment.SpecialFolder.AdminTools);
            Include(Environment.SpecialFolder.CommonDesktopDirectory);
            
            Include(Environment.SpecialFolder.ApplicationData);
            Include(Environment.SpecialFolder.LocalApplicationData);
            Include(Environment.SpecialFolder.MyPictures);
            Include(Environment.SpecialFolder.CommonDocuments);
            Include(Environment.SpecialFolder.CommonMusic);
            Include(Environment.SpecialFolder.CommonPictures);
            Include(Environment.SpecialFolder.UserProfile);
            Include(Environment.SpecialFolder.CommonVideos);

            //exclude
            Exclude(Environment.SpecialFolder.CommonApplicationData);
            Exclude(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "temp"));
            Exclude(Environment.SpecialFolder.InternetCache);
            Exclude(Environment.SpecialFolder.Cookies);
            Exclude(Environment.SpecialFolder.History);
            Exclude(Environment.SpecialFolder.Windows);
            Exclude(Environment.SpecialFolder.System);
            Exclude(Environment.SpecialFolder.ProgramFiles);
            Exclude(Environment.SpecialFolder.SystemX86);
            Exclude(Environment.SpecialFolder.ProgramFilesX86);
            Exclude(Environment.SpecialFolder.CommonProgramFiles);
            Exclude(Environment.SpecialFolder.CommonProgramFilesX86);
            Exclude(Environment.SpecialFolder.CommonTemplates);
            Exclude(Environment.SpecialFolder.Resources);
            Exclude(Environment.SpecialFolder.LocalizedResources);
            Exclude(Environment.SpecialFolder.CommonOemLinks);
            Exclude(Environment.SpecialFolder.CDBurning);

            // find all exclude and include all siblings of parent
            bool bRetry = true;
            while( bRetry )
            {
                bRetry = false;
                foreach(KeyValuePair<string, FolderTempNodeInfo> elem in mapPathToNode)
                {
                    if( elem.Value.Excluded)
                    {
                        if( ProcessExcludedFolder(elem.Value) )
                        {
                            bRetry = true;
                            break;
                        }
                    }
                }
            }

        }

        private void Include(Environment.SpecialFolder folder)
        {
            Include(Environment.GetFolderPath(folder));
        }
        private void Include(string folderPath)
        {
            if (!string.IsNullOrEmpty(folderPath))
            {
                System.Diagnostics.Debug.WriteLine( string.Format("Include {0}", folderPath));
                string[] parts = folderPath.Split(new char[]{'\\'}, StringSplitOptions.RemoveEmptyEntries);
                StringBuilder curPath = new StringBuilder();
                FolderTempNodeInfo curNode = root;
                for (int i = 0; i < parts.Length; i++)
                {
                    if (i > 0)
                        curPath.Append("\\");
                    curPath.Append(parts[i]);

                    string usedPath = curPath.Length == 2 && curPath[1] == ':' ? curPath.ToString() + "\\" : curPath.ToString();
                    if (!mapPathToNode.ContainsKey(usedPath))
                    {
                        FolderTempNodeInfo newNode = new FolderTempNodeInfo(usedPath);
                        newNode.Included = i == parts.Length - 1;
                        curNode.SubFolders.Add(newNode);
                        newNode.ParentNode = curNode;
                        mapPathToNode.Add(newNode.FolderPath, newNode);
                        curNode = newNode;
                    }
                    else
                    {
                        curNode = curNode.FindSubFolder(usedPath);
                        if (i == parts.Length - 1)
                            curNode.Included = true;
                    }
                }
            }
        }
        private void Exclude(Environment.SpecialFolder folder)
        {
            Exclude(Environment.GetFolderPath(folder));
        }
        private void Exclude(string folderPath)
        {
            if (!string.IsNullOrEmpty(folderPath))
            {
                System.Diagnostics.Debug.WriteLine(string.Format("Exclude {0}", folderPath));
                string[] parts = folderPath.Split('\\');
                StringBuilder curPath = new StringBuilder();
                FolderTempNodeInfo curNode = root;
                for (int i = 0; i < parts.Length; i++)
                {
                    if (i > 0)
                        curPath.Append("\\");
                    curPath.Append(parts[i]);
                    string usedPath = curPath.Length == 2 && curPath[1] == ':' ? curPath.ToString() + "\\" : curPath.ToString();
                    if (!mapPathToNode.ContainsKey(usedPath))
                    {
                        FolderTempNodeInfo newNode = new FolderTempNodeInfo(usedPath);
                        newNode.Excluded = i == parts.Length - 1;
                        curNode.SubFolders.Add(newNode);
                        newNode.ParentNode = curNode;
                        mapPathToNode.Add(newNode.FolderPath, newNode);
                        curNode = newNode;
                    }
                    else
                    {
                        curNode = curNode.FindSubFolder(usedPath);
                        if (i == parts.Length - 1)
                            curNode.Excluded = true;
                    }
                }
            }
        }

        private bool ProcessExcludedFolder(FolderTempNodeInfo node)
        {
            bool changedSomething = false;
            for (FolderTempNodeInfo curNode = node;
                 curNode.ParentNode != null && (!string.IsNullOrEmpty(curNode.ParentNode.FolderPath)) && (!curNode.ParentNode.Excluded) && (curNode.ParentNode.Included || !curNode.ParentNode.IsExcludedByParent); 
                 curNode = curNode.ParentNode)
            {
                DirectoryInfo[] siblingFolders = new DirectoryInfo(curNode.ParentNode.FolderPath).GetDirectories();
                foreach (DirectoryInfo siblingFolder in siblingFolders)
                {
                    if (string.Compare(siblingFolder.FullName, curNode.FolderPath, true) != 0
                            && (siblingFolder.Attributes & FileAttributes.System) == 0)
                    {
                        if (!mapPathToNode.ContainsKey(siblingFolder.FullName))
                        {
                            FolderTempNodeInfo newNode = new FolderTempNodeInfo(siblingFolder.FullName);
                            newNode.IncludedByExclude = true;
                            curNode.ParentNode.SubFolders.Add(newNode);
                            newNode.ParentNode = curNode.ParentNode;
                            mapPathToNode.Add(newNode.FolderPath, newNode);
                            changedSomething = true;
                        }
                    }
                }
            }
            return changedSomething;
        }

        public string GetGeneratedExclusions(string dirPath)
        {
            StringBuilder result = new StringBuilder(",");
            List<string> workload = new List<string>();
            workload.Add(dirPath);

            while( workload.Count>0 )
            {
                string cur = workload[0];
                workload.RemoveAt(0);
                FileInfo curInfo = new FileInfo(cur);
                if ((curInfo.Attributes & (FileAttributes.ReparsePoint | FileAttributes.System)) == 0)
                {
                    if (string.Compare(curInfo.Name, "cache", true) == 0
                     || string.Compare(curInfo.Name, "dmrccache", true) == 0                        
                     || string.Compare(curInfo.Name, "caches", true) == 0                       
                     || string.Compare(curInfo.Name, "SystemCache", true) == 0                      
                     || string.Compare(curInfo.Name, "ReportArchive", true) == 0)
                    {
                        if( result.ToString().IndexOf("," + curInfo.Name + ",", StringComparison.InvariantCultureIgnoreCase) < 0 )
                        {
                            result.Append("*\\");
                            result.Append(cur);
                            result.Append("\\*,");
                        }
                    }
                    else
                    {
                        try
                        {
                            string[] subDirs = Directory.GetDirectories(cur);
                            foreach (string curSubDir in subDirs)
                            {
                                workload.Add(curSubDir);
                            }
                        }
                        catch
                        {
                            // just skip unaccessible folders
                        }
                    }
                }
            }
            return result.Length < 3 ? string.Empty : result.ToString().Substring(1, result.Length - 2);
        }

        public List<SourceDefinition> Directories
        {
            get 
            { 
                List<SourceDefinition> result = new List<SourceDefinition>();
                Dictionary<string,SourceDefinition> map = new Dictionary<string,SourceDefinition>();

                foreach (KeyValuePair<string, FolderTempNodeInfo> elem in mapPathToNode)
                {
                    if (elem.Value.SubFolders.Count == 0 && (elem.Value.Included || elem.Value.IncludedByExclude) && ! elem.Value.Excluded)
                        result.Add(new SourceDefinition(elem.Key, GetGeneratedExclusions(elem.Key)));
                }

                result.Sort((op1, op2) => { return string.Compare(op1.SourceDirectory, op2.SourceDirectory); });
                return result; 
            }
        }

    }
}
